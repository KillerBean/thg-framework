# -*- coding: binary -*-
'''
require 'rex/proto/smb'
require 'rex/proto/ntlm'
require 'rex/proto/dcerpc'
require 'rex/encoder/ndr'
require 'recog'

module Msf
module Exploit::Remote::SMB
# This mixin provides utility methods for interacting with a SMB/CIFS service on
# a remote machine.  These methods may generally be useful in the context of
# exploitation.  This mixin extends the Tcp exploit mixin. Only one SMB
# service can be accessed at a time using this class.
#module Client
#include Msf::Exploit::Remote::Tcp
#include Msf::Exploit::Remote::NTLM::Client
# These constants are unused here, but may be used in some code that
# includes this. Local definitions should be preferred.
#SIMPLE = Rex::Proto::SMB::SimpleClient
#XCEPT  = Rex::Proto::SMB::Exceptions
#CONST  = Rex::Proto::SMB::Constants
# Alias over the Rex DCERPC protocol modules
#DCERPCPacket   = Rex::Proto::DCERPC::Packet
#DCERPCClient   = Rex::Proto::DCERPC::Client
#DCERPCResponse = Rex::Proto::DCERPC::Response
#DCERPCUUID     = Rex::Proto::DCERPC::UUID
#NDR            = Rex::Encoder::NDR
'''

#require 'rex/proto/dcerpc/svcctl'
#require 'windows_error'
#require 'windows_error/win32'
#require 'msf/core/exploit/exe'
#require 'msf/core/exploit/wbemexec'
#include WindowsError::Win32
#module Msf
####
# Makes use of a WebEx service vulnerability that works similarly to psexec.
#
# This code was stolen straight out of the psexec module which was stolen from
# the standalone Psexec tool. Thanks very much for all who contributed to that
# module!! Instead of uploading and running a binary.
####
#module Exploit::Remote::SMB::Client::WebExec
#  include Msf::Exploit::Windows_Constants
#  include Msf::Exploit::Remote::DCERPC
#  include Msf::Exploit::Remote::SMB::Client::Authenticated
#  include Msf::Exploit::Failure

from lib.thg.base.BaseOptions import BaseOption
from lib.thg.base.BaseOptions import BaseOptions
from lib.thg.base.BaseResult import BaseResult

class BaseAuxiliary_Drdos:
    name = None #nome do auxiliar
    description = None #descricao do auxiliar
    author = [] # nome do autor
    references = []#referenia do exploit
    disclosure_date = None #data de divulgacao
    service_name = None #nome do servico
    service_version = None #versao do servico
    dbinfo = ['name', 'description', 'author', 'references', 'disclosure_date', 'service_name', 'service_version']#info database
    multi_target = False#vvarios alvos
    targets = []#alvo
    target_type = None#tipo de alvo
    options = None #opcoes
    results = None #resultados

    def __init__(self):
        self.multi_target = False
        self.target_type = None
        self.targets = []
        self.options = BaseOptions()
        self.results = BaseResult()

    def get_info(self):
        info = {}
        for field_name in self.dbinfo:
            info[field_name] = getattr(self, field_name)
        return info

    def register_client_dns(self):
      self.register_options([
        BaseOption(name='SMB::pipe_evasion', required=True, description='Enable segmented read/writes for SMB Pipes', value=False),
        BaseOption(name='SMB::pipe_write_min_size', required=True, description='Minimum buffer size for pipe writes', value=1),
        BaseOption(name='SMB::pipe_write_max_size', required=True, description='Maximum buffer size for pipe writes',  value=1024),
        BaseOption(name='SMB::pipe_read_min_size', required=True, description='Minimum buffer size for pipe reads',  value=1),
        BaseOption(name='SMB::pipe_read_max_size', required=True, description='Maximum buffer size for pipe reads',  value=1024),
        BaseOption(name='SMB::pad_data_level', required=True, description='Place extra padding between headers and data (level 0-3)',  value=0),
        BaseOption(name='SMB::pad_file_level', required=True, description='Obscure path names used in open/create (level 0-3)',  value=0),
        BaseOption(name='SMB::obscure_trans_pipe_level', required=True, description='Obscure PIPE string in TransNamedPipe (level 0-3)', value=0),
        BaseOption(name='SMBDirect', required=False, description='The target port is a raw SMB service (not NetBIOS)', value=True),
        BaseOption(name='SMBUser', required=False, description='The username to authenticate as', value=''),
        BaseOption(name='SMBPass', required=False, description='The password for the specified username', value=''),
        BaseOption(name='SMBDomain', required=False, description='The Windows domain to use for authentication', value='.'),
        BaseOption(name='SMBName', required=True, description='The NetBIOS hostname (required for port 139 connections)', value='*SMBSERVER'),
        BaseOption(name='SMB::VerifySignature', required=True, description="Enforces client-side verification of server response signatures",value=False),
        BaseOption(name='SMB::ChunkSize', required=True, description='The chunk size for SMB segments, bigger values will increase speed but break NT 4.0 and SMB signing', value=500),
        #
        # Control the identified operating system of the client
        #
        BaseOption(name='SMB::Native_OS', required=True, description='The Native OS to send during authentication',  value='Windows 2000 2195'),
        BaseOption(name='SMB::Native_LM', required=True, description='The Native LM to send during authentication',  value='Windows 2000 5.0'),
        BaseOption(name='RHOST', required=True, description="Remote Host to connect"),
        BaseOption(name='RPORT', required=True, description='The SMB service port', value=445)

  ])

    def thg_update_info(self, info):
        for name in info:
            if name in self.dbinfo:
                setattr(self, name, info[name])

    def register_options(self, option_array):
        for option in option_array:
            self.options.add_option(option)

    def get_missing_options(self):
        def is_missing(option):
            return option.required and option.value in [None, '']

        missing_options = filter(is_missing, self.options.get_options())
        return list(missing_options)