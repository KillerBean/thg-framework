# -*- coding: binary -*-

#module Msf
#module Exploit::Remote::SMB
#This mixin provides a minimal SMB server
#module Server
#include Msf::Exploit::Remote::TcpServer
#include Msf::Exploit::NTLM
#CONST = ::Rex::Proto::SMB::Constants
#CRYPT = ::Rex::Proto::SMB::Crypt
#UTILS = ::Rex::Proto::SMB::Utils
#XCEPT = ::Rex::Proto::SMB::Exceptions
#EVADE = ::Rex::Proto::SMB::Evasions
#deregister_options('SSL', 'SSLCert')
#require 'rex/proto/dcerpc/svcctl'
#require 'windows_error'
#require 'windows_error/win32'
#require 'msf/core/exploit/exe'
#require 'msf/core/exploit/wbemexec'
#include WindowsError::Win32
#module Msf
####
# Makes use of a WebEx service vulnerability that works similarly to psexec.
#
# This code was stolen straight out of the psexec module which was stolen from
# the standalone Psexec tool. Thanks very much for all who contributed to that
# module!! Instead of uploading and running a binary.
####
#module Exploit::Remote::SMB::Client::WebExec
#  include Msf::Exploit::Windows_Constants
#  include Msf::Exploit::Remote::DCERPC
#  include Msf::Exploit::Remote::SMB::Client::Authenticated
#  include Msf::Exploit::Failure

from lib.thg.base.BaseOptions import BaseOption
from lib.thg.base.BaseOptions import BaseOptions
from lib.thg.base.BaseResult import BaseResult

class BaseAuxiliary_Drdos:
    name = None #nome do auxiliar
    description = None #descricao do auxiliar
    author = [] # nome do autor
    references = []#referenia do exploit
    disclosure_date = None #data de divulgacao
    service_name = None #nome do servico
    service_version = None #versao do servico
    dbinfo = ['name', 'description', 'author', 'references', 'disclosure_date', 'service_name', 'service_version']#info database
    multi_target = False#vvarios alvos
    targets = []#alvo
    target_type = None#tipo de alvo
    options = None #opcoes
    results = None #resultados

    def __init__(self):
        self.multi_target = False
        self.target_type = None
        self.targets = []
        self.options = BaseOptions()
        self.results = BaseResult()

    def get_info(self):
        info = {}
        for field_name in self.dbinfo:
            info[field_name] = getattr(self, field_name)
        return info

    def register_client_dns(self):
      self.register_options([
            BaseOption(name='SRVPORT', required=True, description= 'The local port to listen on.', value=445 ),
            BaseOption(name='SMBServerMaximumBuffer', required=True, description= 'The maximum number of data in megabytes to buffer', value=2 ),
            BaseOption(name='SMBServerIdleTimeout', required=True, description= 'The maximum amount of time to keep an idle session open in seconds', value=120)

  ])

    def thg_update_info(self, info):
        for name in info:
            if name in self.dbinfo:
                setattr(self, name, info[name])

    def register_options(self, option_array):
        for option in option_array:
            self.options.add_option(option)

    def get_missing_options(self):
        def is_missing(option):
            return option.required and option.value in [None, '']

        missing_options = filter(is_missing, self.options.get_options())
        return list(missing_options)

